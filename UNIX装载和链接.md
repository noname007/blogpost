
1. 下面这个外壳调用操作系统中一个叫做加载器的函数，它拷贝可执行文件p中的代码和数据到存储器，然后将控制转移到这个程序的开头
2. 静态连接 包含两个步骤:符号解析和重定位，输入为一组可重定位目标文件和命令行参数，输出为一个完全连接的可以加载和运行的可执行目标文件作为输出。
3. 目标文件 
	- 可重定位目标文件 包含二进制代码和数据，其形式可以在**编译时**与其他可重定位目标文件合并起来，创建一个可执行目标文件
	- 可执行目标文件 包含二级制代码和数据，其形式可以被直接拷贝到存储器并执行 
	- 共享目标文件 一种特殊的可重定位目标文件，可以在**加载或者运行时**被动态的加载到存储器并连接
 各个系统之间的目标文件格式都不尽相同
 	- System V Unix的早期版本使用的是一般目标文件格式COFF(common object file format)
 	- Windows NT使用的是COFF的变种PE(Portable Executable)可移植可执行
	- 现代Unix系统（BSD Linux、Sun Solaris）使用的是ELF（Executable andLinkable Format）可执行和可连接格式
4. 可重定位目标文件 ELF头以一个16字节序列开始，这个序列告诉我们系统字的大小和字节顺序、
节头部表中的位置、节头部表中的条目大小和数量、ELF头的大小、目标文件类型、机器类型等。而节头部表中约定了不同节的位置和大小。
![](http://ww4.sinaimg.cn/large/4483e99egw1ete23qo6d1j20b10bl0tj.jpg)
常见的几个节：
	- text已编译的程序代码
	- rodata只读数据 比如printf语句中的格式串和开关语句的跳转表
	- data/.bss 已初始化/未初始化的全局C变量
	- symtab 符号表，存放在程序中定义和引用的函数和全局变量的信息。和编译器中的符号表不同，.symtab不包含局部变量的条目。
	- rel.text 一个.text节中位置的列表，当连接器把这个目标文件和其他文件结合时，需要修改这些位置。可执行目标文件并不需要重定位信息，因此通常忽略。
	- rel.data 类似上面
	- **.debug** 调试符号表，其中内容不仅包含了程序中定义的局部变量、全局变量、类型定义和原始的源C文件，只有以-g编译驱动程序时才会得到这张表
	- **.line** 原始C源程序中的行号和.text节中机器指令的映射，-g选项调用编译驱动程序才会得到
	- strtab一个字符串表，其中包括.symtab和.debug节中的符号表，以及节头部中的节名字
5. 符号和符号表 符号表中只存储全局符号和只被本模块定义和引用的本地符号。.symtab中的符号表不包含对应于本地**非静态**程序变量的任何符号，这些符号在运行时在栈中被管理，连接器对此类符号不感兴趣。但是**静态**的本地过程变量是不在栈中管理的，相反，编译器在.data和.bss中为每个定义分配空间，并在符号表中创建创建一个有唯一名字的本地连接器符号
6. 符号解析 函数重载的是一种特殊情况，虽然在代码层函数名称相同，但是编译器在编译的时候会将每个唯一的方法和参数列表组合成编码一个队连接器来说唯一的名字。**函数和初始化的全局变量是强符号。未初始化的全局变量是弱符号**。如果出现多重定义，UNIX连接器则使用下列的规则来处理多重定义的符号：
 	1. 不允许有多个强符号
	2. 如果有一个强符号和多个弱符号，那么选择强符号
	3. 如果有多个弱符号，那么从这些弱符号中任意选择一个
7. 静态库 链接器在连接时，只拷贝被程序引用的目标模块，这就减少了可执行文件在磁盘和存储器中的大小。顺序会影响静态库的链接
8. 链接器重定位：一旦完成符号解析过程后，链接器将所有相同类型的节合并成同一类型的新的聚合节，并重新赋予节中各符号的运行时存储器地址，当这个步骤完成时，程序中每个指令和全局变量都有唯一的运行时存储器地址了。而之后，进行的**符号引用**修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。
9. 程序执行的过程
	- 当加载器执行时，在可执行文件中段头部表的指导下，加载器将可执行文件的内容拷贝到代码和数据段
	- 加载器跳到程序入口点，符号_start的地址，这个在所有C程序是一样的。
	- 在.text和.init节中调用了初始化例程后，执行了atexit，这个作用附加了程序正常终止时应该调用的程序【exit函数会运行atexit时注册的函数，然后通过调用_exit将控制返回给操作系统】
	- 调用应用程序的main程序
	- main结束后，会执行"_exit()"程序，将控制返回给操作系统；如果main程序中主动执行了exit,那么会首先执行atexit时注册的函数，然后通过调用"_exit"将控制返回给操作系统
10. 共享库是致力于解决静态缺陷的一个现代创新产物，共享库是一个目标文件，它在运行的时候，可以加载到任意的存储器地址，冰河一个在存储器中的程序链接起来，这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的。
11. 在连接共享库的时候并没将共享库的代码和数据节拷贝入可执行文件，而是拷贝了一些重定位和符号表信息。加载器看到.interp节后加载和运行动态链接器，动态链接器通过执行下面的重定位完成连接任务。
	- 重定位动态库中的文本和数据到某个存储器段
	- 重定位可执行文件中对动态库的符号的引用
12. linux系统为动态链接器提供了一个简单地接口，允许应用程序在运行时加载和链接共享库。
	
	```
	#include <dlfcn.h>
	void *dlopen(const char *filename,int flag);
	```
	
13. 	- dlsym函数的输入是一个指向前面已经打开共享库的句柄和一个符号的名字，如果符号存在就返回符号的地址，否则返回NULL
		- dlclose 卸载已经加载的且目前未被使用的共享库
14. 目标里面还有可能保存调试信息，gcc -g参数会使编译器产生的目标文件，ELF文件采用一个叫DWARF的标准的调试信息格式
15. 



	

 



