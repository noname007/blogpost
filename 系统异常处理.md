# 系统异常处理
## 基本概念
- 现代控制系统的核心 异常控制流ECF（Exception Control Flow）
- 异常是异常控制流中的一种形式，指代控制流中的突变。
- 状态变化称为事件，当事件发生时，处理器会通过一张叫“异常表”的跳转表，进行一个间接过程调用，调用专门处理这类事件的异常处理程序。当异常处理程序完成处理后，将会进行如下三种操作之一
  - 处理程序返回给当前指令Icurr
  - 处理程序返回给Inext，没有异常时将会执行的下一条指令
  - 处理程序终止被中断的程序

## 异常处理
- 异常处理程序往往运行在内核模式下，这种模式下，它们对所有的系统资源具有完全的访问权限
，而且所有相关状态、返回地址神马的都会压入到内核栈中，而不是被压到用户栈中。
- 异常类别
  - 中断 interrupt 有外部设备I/O引起，发生的过程是异步的，因为事件发生，可能信号发出后
  并没有及时处理；
  - 陷阱 trap 有意的异常-系统调用
  - 故障 fault 返回到当前指令，从新执行；如果处理不了，就会被abort；经典故障：缺页
  - 终止 abort
  - 各种比较图
  ![](http://ww4.sinaimg.cn/large/4483e99egw1ethc6trheaj20rm061abt.jpg)

## 进程
- 并行流是并发流的真子集，如果两个流并发的运行在不同的处理器和或者计算机上，他们就
称为并行流
- 进程地址空间
  ![](http://ww3.sinaimg.cn/large/4483e99egw1ethh09poxzj20ia0k0q7f.jpg)
- 一旦设置模式位，进程就会运行在内核模式，会获得系统完全的资源，并可进行特权指令，而且可以直接
引用地址空间中内核区内的代码和数据。
- 进程由用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的
异常。
- 通过fork新创建的子进程几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间
相同的一份拷贝（两者相互独立），包括文本、数据和bss段、堆以及用户栈。子进程可以读写父进程中打开
的任何文件。最大的区别两者有不同的pid
- 作为程序员，决不能对不同进程中指令的交替执行做任何假设
- SIGKILL这个信号不能被捕获，也不能被忽略。
- 在任何时刻，一种类型至多只会有一个待处理信号。信号机制都是基于进程组，而进程组可以通过使用
setpgid函数来改变自己或者其他进程的进程组。
- 信号处理可能会出现的问题，需要自行处理解决
  - 待处理信号被阻塞 信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号
  - 待处理信号不会排队等候
  - 系统调用可以被中断像read、wait和accept，一旦被中断，这些系统调用在信号处理程序返回时不再继续，而是
  立即返回给用户的一个错误条件，并将errno设置为EINTR。Solaris系统调用被信号中断后是不会自动重启的
  而Linux回自动重启被中断的系统调用
- 正因为上述信号的问题，所以不可以用新号来对其他进程中发生的事件计数。
