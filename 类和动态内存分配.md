1. 当您用一个对象初始化另一个对象时，编译器会自动生成拷贝构造函数，创建对象的一个副本。
2. C++ 自动提供以下成员函数，如果没有定义的话：
	- 默认构造函数
	- 默认析构函数
	- 复制构造函数
	- 赋值运算符
	- 地址运算符
	- 移动构造函数（C++11）
	- 移动赋值运算符（C++11）
	
3. 每当程序生成了对象副本时，编译器将使用复制构造函数，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。默认的复制构造函数逐个复制非静态成员，复制的是成员的值。
4. 必须定义复制构造函数的原因在于，一些类成员使用new初始化的，指向数据的指针，而不是数据本身。如果析构函数涉及到析构指针的操作的话，浅复制会导致指向非法位置。
5.  
 - 构造函数不能是虚函数
 - 即使积累不需要显示析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数即使他不执行任何操作。
 - 友元不能是虚函数
 - 重新定义会隐藏基类函数声明
6. 总之，当基类和派生类都采用动态内存分配，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素，这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的：对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的，如果不这样做，将自动调用基类的默认构造函数，对于赋值运算符，这是通过使用作用域解析运算符显式的调用基类的赋值运算符来完成的。
7. 
