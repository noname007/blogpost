# 《C和指针》读书笔记
1. 你必须记住，变量名称与内存位置之间的关联并不是硬件提供的，它是由编译器为我们实现的。硬件仍然通过地址访问内存位置
2.  不能简单的通过检查一个值的位来判断它的类型，为了判断值的类型以及他的值，你必须观察程序中这个值的使用方式。值的类型并非值本身所固有的一种特性，而是取决于它的使用方式。
3.  一个变量的值就是分配给这个变量的内存位置所存储的值，指针变量的值就是存放的地址
4. 指针变量和其他变量并无区别，如果变量是静态的，它会被初始化为0，如果变量是自动的，它根本不会被初始化。访问一个未初始化的地址会导致发生的错误，在UNIX系统上，这个错误被称为“段违例错误（segmentation violation）或内存错误（memory fault）” 在windows上，对未初始化或非法治镇进行间接地访问操作会导致一般保护性异常的根源之一
5. ANSI C标准定义了NULL指针，它作为一个特殊的指针变量，标示不知向任何东西，要使一个指针变量为NULL，你可以给它赋值一个零值。为了测试一个指针变量是否为NULL，你可以将它与零值进行比较。之所以选择零这个值是因为一种源代码约定，就机器内部而言，NULL指针的实际值可能与此不同。在这种情况下，编译器将负责零值和内部值之间的转换。
6.  对一个NULL指针进行解引用操作是非法的，在对指针进行解引用操作之前，你首先必须确保它并非NULL指针。
7. 指针常量。```*100=25；``` 非法语句，因为100是整型，而间接访问操作只能作用于指针类型表达式，所以需要强制转型，变为 ```*(int *)100 = 25```;
8. 让指针指向数组最后一个元素后面的那个位置是合法的，但对这个指针执行间接访问可能会失败。
9. 实际上，绝大多数编译器都不会检查指针表达式的结果是否位于合法的边界之内，因此，程序员应该负起责任，确保这一点，越界指针和指向未知值的指针是两个常见的错误根源，当你使用指针运算时，必须非常小心，确信运算的结果将指向有意义的东西。

