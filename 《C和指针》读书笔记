# 《C和指针》读书笔记
1. 你必须记住，变量名称与内存位置之间的关联并不是硬件提供的，它是由编译器为我们实现的。硬件仍然通过地址访问内存位置
2.  不能简单的通过检查一个值的位来判断它的类型，为了判断值的类型以及他的值，你必须观察程序中这个值的使用方式。值的类型并非值本身所固有的一种特性，而是取决于它的使用方式。
3.  一个变量的值就是分配给这个变量的内存位置所存储的值，指针变量的值就是存放的地址
4. 指针变量和其他变量并无区别，如果变量是静态的，它会被初始化为0，如果变量是自动的，它根本不会被初始化。访问一个未初始化的地址会导致发生的错误，在UNIX系统上，这个错误被称为“段违例错误（segmentation violation）或内存错误（memory fault）” 在windows上，对未初始化或非法治镇进行间接地访问操作会导致一般保护性异常的根源之一
5. ANSI C标准定义了NULL指针，它作为一个特殊的指针变量，标示不知向任何东西，要使一个指针变量为NULL，你可以给它赋值一个零值。为了测试一个指针变量是否为NULL，你可以将它与零值进行比较。之所以选择零这个值是因为一种源代码约定，就机器内部而言，NULL指针的实际值可能与此不同。在这种情况下，编译器将负责零值和内部值之间的转换。
6.  对一个NULL指针进行解引用操作是非法的，在对指针进行解引用操作之前，你首先必须确保它并非NULL指针。
7. 指针常量。```*100=25；``` 非法语句，因为100是整型，而间接访问操作只能作用于指针类型表达式，所以需要强制转型，变为 ```*(int *)100 = 25```;
8. 让指针指向数组最后一个元素后面的那个位置是合法的，但对这个指针执行间接访问可能会失败。
9. 实际上，绝大多数编译器都不会检查指针表达式的结果是否位于合法的边界之内，因此，程序员应该负起责任，确保这一点，越界指针和指向未知值的指针是两个常见的错误根源，当你使用指针运算时，必须非常小心，确信运算的结果将指向有意义的东西。
10. 当程序调用一个无法见到原型的函数时，编译器便认为该函数返回一个整型值，对于那些不返回整型值的函数，这种认定可能会引发错误。所有函数都应具有原型。
11.  C函数的所有参数都是以“传值调用”方式进行传递
12.  当你使用递归方式实现一个函数之前，先问问你自己是用递归带来的好处是否抵得上它的代价，而且你必须要小心，这个代价可能比初看上去要大得多
13. 除了优先级之外，下标引用和间接访问完全相同。
	
	```
	array[subscript]
	*(array +(subscript))
	
	```
	
14.  提高编程效率的几点方法：
	1. 当你根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现会尤为突出
	2. 声明为寄存器变量的指针通常比位于静态内存和堆栈中指针效率更高
	3. 如果你可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止，那么你就不需要使用一个单独的计数器
	4. 那些必须在运行时求值的表达式相较在编译时就能确定的常量表达式往往代价更高。
15. 存储于静态内存的数组只初始化一次，也就是在程序开始执行之前，程序并不需要执行指令把这些值放到合适的位置，它们一开始就在那里了。这个魔术是由链接器完成的。链接器用包含可执行程序的文件中的合适的值对数组元素进行初始化，如果数组未被初始化，数组元素的初始值将会被自动设置为0.因此当程序执行时，静态数组已经初始化完毕。
16. 有个例子 

```
char message[] = "hello";
char *message2 = "hello";

```
这两个初始化看上去很像，但他们具有不同的含义。前者初始化一个字符数组的元素，而后者则是一个真正的字符串常量。这个指针变量被初始化为指向这个字符串常量的存储位置。

17.  在多维数组中，只有第一维才能根据初始化列表缺省地提供，剩余几个维必须显示地写出，这样编译器就能推断出每个子数组维数的长度。
18.  在绝大多数的表达式中，数组名的值是指向数组第一个元素的指针，这个规则只有两个例外，sizeof 返回整个数组所占用的字节而不是一个指针所占用的自己，单目操作符&返回一个指向数组的指针，而不是一个指向数组第一个元素的指针的指针。
19. 