# 	Lua  虚拟机研究 与 C语言交互

## 目录
1.  综述
2.  源码概述
3. 元表以及元方法
4. 虚拟机
5. C API交互


## 综述
Lua 这门编程语言是一门动态编程语言，具有简洁清晰的语法，需要借助虚拟机来运行。Lua代码最终都是以字节码的形式由虚拟机解释执行的。 把外部组织好的代码置入内存，让虚拟机解析执行，需要有源代码解释器和预编译字节码的加载器。官方实现提供了一个解释器，除此之外，LuaJIT提供了编译为本地语言的实现方式，采用JIT技术即时编译Lua源代码为机器语言。我们采用的是后者，即LuaJIT。LuaJIT截止到当前，最新稳定版本为2.0.4，支持全部Lua 5.1以及部分5.2的语法。

## 源码概述

以下为官方Lua标准实现解读，以Lua5.3.1 为例。 源码结构如下：
![](http://ww2.sinaimg.cn/large/4483e99egw1exwzr66sm8j20mo0omn5b.jpg)
从图中可以看到，所有的源码都放在SRC目录下，以下所有文件根据实现功能的不同，可以划分为4大类。

1. 虚拟机运转的核心功能
	- lapi.c C语言接口
	- lctype.c C标准库中ctype相关实现
	- ldebug.c debug接口
	- ldo.c  函数调用以及栈管理
	- lfunc.c 函数原型以及闭包管理
	- lgc.c  垃圾回收
	- lmem.c 内存管理的接口
	- lobject.c 对象操作的一些函数
	- lopcodes.c 虚拟机的字节码定义
	- lstate.c 全局状态机
	- lstring.c 字符串池
	- ltable.c 表类型的相关操作
	- ltm.c 元方法
	- lvm.c 虚拟机
	- lzio.c 输入流接口
2. 源代码解析以及预编译字节码
	- lcode.c 代码生成器
	- ldump.c 序列化编译的Lua字节码
	- llex.c 词法器
	- lparser.c 解析器
	- lundump.c 还原预编译的字节码
3. 内嵌库
	- lauxlib.c 辅助函数库
	- lbaselib.c 基础库
	- lbitlib.c 位操作库
	- lcorolib.c 协程库
	- ldblib.c Debug库
	- linit.c 内嵌库的初始化
	- liolib.c IO库
	- lmathlib.c 数学库
	- loadlib.c 动态扩展库管理
	- loslib.c 操作系统库
	- lstrlib.c 字符串库
	- ltablib.c 表处理库
4. 可执行的解析器、字节码编译器
	- lua.c 解释器
	- luac.c 字节码编译器

lua核心部分仅包括Lua虚拟机的运转，Lua虚拟机的行为是由一组组opcode控制的。这些opcode定义在lopcodes.h及lopcodes.c中。而虚拟机对opcode的解析和运作在lvm.c中，其API以luaV为前缀。
lua虚拟机的外在数据形式是一个luaState结构体， 全局State引用了整个虚拟机的所有数据，这个全局state的相关代码放在lstate.c中。函数的运行流程、函数调用以及返回则放在ldo.c中，Lua中最复杂和最重要的三种数据类型function、table、string的实现分别存在于lfunc.c、ltable.c、lstring.c 中，最为复杂的部分垃圾回收的部分则实现于lgc.c中。Lua程序的源代码需要经过解析得到内部的数据结构（常量和opcode的结合）这个过程是是通过解析器lparser.c和词法分析llex.c 分析的。官方实现了一个简单的独立解析器，便是lua.c所实现的，并有luac.c实现了一个简单地字节码编译器，可以将字节码简单地存下来，方便被别的解析器或编译器进行编译。

## 元表和元方法
可以通过元表来修改一个值的行为，使其在面对一个非预定义的操作时执行一个指定的操作。元表的概念有点类似于JS中的Prototype ，我们修改的值变为元方法。Lua中的每个值都有一个元表，table 和userdata 可以有各自独立的元表，而其他类型的值则共享其类型所属的单一元表。

举个栗子：

当两个集合相加时，可以使用任意一个集合的元表。然而当一个表达式中混合了具有不同元表的值时，Lua会按照如下的步骤来查找元表：如果第一个值有元表并且元表中有对应的元方法，那么Lua会将此集合的元方法设为__add方法。反之，如果第二个值有元表并含有__add方法，Lua就以此字段为元方法。如果两个值都没有元方法，lua就引发一个错误。

- table访问的元方法
	- __index元方法 当访问一个table中不存在的字段时，得到的结果为nil，实际上，这些访问会促使解释器去查找一个叫做的__index的元方法。如果没有这个元方法，那么访问结果如前述的为nil。否则，就有这个元方法提供来提供最终结果。
	- __newindex 元方法 __newinde元方法与__index 类似，不同之处在于前者用于table的更新，而后者用于table的查询。当对一个table中不存在的索引赋值时，解释器就会查找__newindex元方法。如果有这个元方法，解释器就调用它，而不是执行赋值。

## 虚拟机

Lua中的每一条指令都由一个32位无符号整数标示。指令种类和操作对象都被编码进这个数字。Lua虚拟机是基于寄存器结构实现的,每段 Lua 代码被翻译为一组对256 个寄存器的操作指令。C 函数通常是从L(luaState 虚拟机实例)中取出参数逐个记录在 C的局部变量中,然后 利用C代码直接对这些值进行操作。可以把寄存器类比于Lua的寄存器,C中的局 部变量处于C堆栈上,而Lua的寄存器则处于Lua的数据栈中。

Lua字节码以寄存器的方式来理解数据栈空间,大多数情况下,用到 多少寄存器是在生成字节码的编译期决定的。所以在函数原型结构里有maxstacksize这个信息,同时在运行 时,会把这段空间的顶端记录在CallInfo的top中。虚拟机运行是随机访问这段栈空间的。但Lua虚拟机在 运行时,也会以堆栈的方式利用这个数据栈,这里的luaV_concat就是这样。这种以栈形式利用数据堆栈都 是临时行为,使用完毕后应该重置数据栈顶。

Lua中的函数调用有两种,一种是标准的函数调用,它会需要生成新的一层调用栈,执行函数流程,然 后弹出调用栈返回。另一种叫做尾调用,它是对标准函数调用的优化。尾调用不生成新的调用栈,而不复用 当前的。

每段完整的字节码都是一个Lua 函数。而每个函数里可以附有很多个函数原型。函数原型没有 放在常量表里,而是单独成表。这是因为,它们不可以被 Lua代码直接使用。只有函数原型和 upvalue绑定 在一起时,成为了闭包,才是Lua虚拟机可以处理的对象。

## C API交互
1. C API遵循C语言的操作模式。这与Lua的操作模式大不相同，当在C语言中编程时，应注意类型检测、错误恢复、内存分配错误和其他的源代码复杂性。API中的大多函数不会检测其参数的正确性，但必须保证传入参数的合法性。如果传入了错误的参数，将会得到一个“segmentation fault”或类似的错误。
2. Lua库中没有定义任何全局变量，它将所有的状态都保存在动态结构luaState中，所有的C API都要求传入一个指向该结构的指针。luaL_newstate函数用于创建一个新环境，当luaL_newstate 创建一个新的环境时，新环境中没有包含预定义函数。
3.  在Lua和C语言之间交换数据。栈中的每个元素都能保存任何类型的Lua值。要获取Lua中的一个值时，只要调用一个Lua API函数，Lua就会将指定的值压入栈中，要将一个值传给Lua中。需要先将这个值压入栈，然后调用lua API函数，Lua就会获取该值并将其从栈中弹出。为了将C类型的值压入栈，或者从栈中获取不同类型的值，就需要为每种类型定义一个特定的函数。
4. 通常情况下，应用程序代码是以无保护模式运行的，由于他们不是有Lua调用，Lua无法设置适当的上下文来捕获错误。



